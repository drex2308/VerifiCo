export = IpfsRepo;
/**
 * @typedef {import('./types').Options} Options
 * @typedef {import('./types').Lock} Lock
 * @typedef {import('./types').LockCloser} LockCloser
 * @typedef {import('./types').Stat} Stat
 * @typedef {import('./types').Blockstore} Blockstore
 * @typedef {import('./types').Config} Config
 * @typedef {import('ipld-block')} Block
 * @typedef {import('interface-datastore').Datastore} Datastore
 */
/**
 * IpfsRepo implements all required functionality to read and write to an ipfs repo.
 */
declare class IpfsRepo {
    /**
     * @param {string} repoPath - path where the repo is stored
     * @param {Options} [options] - Configuration
     */
    constructor(repoPath: string, options?: import("./types").Options | undefined);
    options: Required<import("./types").Options> & import("./types").Options;
    closed: boolean;
    path: string;
    /**
     * @private
     */
    private _locker;
    root: import("interface-datastore/dist/src/types").Datastore;
    datastore: import("interface-datastore/dist/src/types").Datastore;
    keys: import("interface-datastore/dist/src/types").Datastore;
    pins: import("interface-datastore/dist/src/types").Datastore;
    blocks: import("./types").Blockstore;
    version: {
        exists(): Promise<any>;
        get(): Promise<number>;
        set(version: number): Promise<void>;
        check(expected: number): Promise<boolean>;
    };
    config: {
        getAll(options?: {
            signal?: AbortSignal | undefined;
        } | undefined): Promise<import("./types").Config>;
        get(key: string, options?: {
            signal?: AbortSignal | undefined;
        } | undefined): Promise<any>;
        set(key: string, value?: any, options?: {
            signal?: AbortSignal | undefined;
        } | undefined): Promise<void>;
        replace(value?: import("./types").Config | undefined, options?: {
            signal?: AbortSignal | undefined;
        } | undefined): Promise<void>;
        exists(): Promise<any>;
    };
    spec: {
        exists(): Promise<boolean>;
        get(): Promise<Uint8Array>;
        set(spec: any): Promise<void>;
    };
    apiAddr: {
        get(): Promise<string>;
        set(value: string): Promise<void>;
        delete(): Promise<void>;
    };
    /**
     * Initialize a new repo.
     *
     * @param {import('./types').Config} config - config to write into `config`.
     * @returns {Promise<void>}
     */
    init(config: import('./types').Config): Promise<void>;
    /**
     * Check if the repo is already initialized.
     *
     * @returns {Promise<boolean>}
     */
    isInitialized(): Promise<boolean>;
    /**
     * Open the repo. If the repo is already open an error will be thrown.
     * If the repo is not initialized it will throw an error.
     *
     * @returns {Promise<void>}
     */
    open(): Promise<void>;
    lockfile: import("./types").LockCloser | null | undefined;
    /**
     * Returns the repo locker to be used.
     *
     * @private
     */
    private _getLocker;
    /**
     * Opens the root backend, catching and ignoring an 'Already open' error
     *
     * @private
     */
    private _openRoot;
    /**
     * Creates a lock on the repo if a locker is specified. The lockfile object will
     * be returned in the callback if one has been created.
     *
     * @private
     * @param {string} path
     * @returns {Promise<LockCloser>}
     */
    private _openLock;
    /**
     * Closes the lock on the repo
     *
     * @private
     */
    private _closeLock;
    /**
     * Check if the repo is already initialized.
     *
     * @private
     */
    private _checkInitialized;
    /**
     * Close the repo and cleanup.
     *
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Check if a repo exists.
     *
     * @returns {Promise<boolean>}
     */
    exists(): Promise<boolean>;
    /**
     * Get repo status.
     *
     * @returns {Promise<Stat>}
     */
    stat(): Promise<Stat>;
    /**
     * @private
     */
    private _isAutoMigrationEnabled;
    /**
     * Internal migration
     *
     * @private
     * @param {number} toVersion
     */
    private _migrate;
    /**
     * @private
     */
    private _storageMaxStat;
    /**
     * @private
     */
    private _blockStat;
}
declare namespace IpfsRepo {
    export { utils, repoVersion, ERRORS as errors, Options, Lock, LockCloser, Stat, Blockstore, Config, Block, Datastore };
}
type Stat = import('./types').Stat;
declare namespace utils {
    const blockstore: typeof import("./blockstore-utils");
}
import ERRORS = require("./errors");
type Options = import('./types').Options;
type Lock = import('./types').Lock;
type LockCloser = import('./types').LockCloser;
type Blockstore = import('./types').Blockstore;
type Config = import('./types').Config;
type Block = import('ipld-block');
type Datastore = import('interface-datastore').Datastore;
//# sourceMappingURL=index.d.ts.map