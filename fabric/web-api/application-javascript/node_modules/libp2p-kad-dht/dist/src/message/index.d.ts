export = Message;
/**
 * @typedef {0|1|2|3|4} ConnectionType
 *
 * @typedef {object} PBPeer
 * @property {Uint8Array} id
 * @property {Uint8Array[]} addrs
 * @property {ConnectionType} connection
 *
 * @typedef {import('../index').PeerData} PeerData
 */
/**
 * Represents a single DHT control message.
 */
declare class Message {
    /**
     * Decode from protobuf
     *
     * @param {Uint8Array} raw
     */
    static deserialize(raw: Uint8Array): import(".");
    /**
     * @param {import('./dht').Message.MessageType} type
     * @param {Uint8Array} key
     * @param {number} level
     */
    constructor(type: import('./dht').Message.MessageType, key: Uint8Array, level: number);
    type: Proto.Message.MessageType;
    key: Uint8Array;
    _clusterLevelRaw: number;
    /** @type {PeerData[]} */
    closerPeers: PeerData[];
    /** @type {PeerData[]} */
    providerPeers: PeerData[];
    /** @type {import('libp2p-record').Record | undefined} */
    record: import('libp2p-record').Record | undefined;
    set clusterLevel(arg: number);
    /**
     * @type {number}
     */
    get clusterLevel(): number;
    /**
     * Encode into protobuf
     */
    serialize(): Uint8Array;
}
declare namespace Message {
    export { MESSAGE_TYPE as TYPES, CONNECTION_TYPE as CONNECTION_TYPES, ConnectionType, PBPeer, PeerData };
}
import Proto = require("./dht");
type PeerData = {
    id: PeerId;
    multiaddrs: Multiaddr[];
};
declare const MESSAGE_TYPE: typeof Proto.Message.MessageType;
declare const CONNECTION_TYPE: typeof Proto.Message.ConnectionType;
type ConnectionType = 0 | 3 | 1 | 4 | 2;
type PBPeer = {
    id: Uint8Array;
    addrs: Uint8Array[];
    connection: ConnectionType;
};
import PeerId = require("peer-id");
import { Multiaddr } from "multiaddr";
//# sourceMappingURL=index.d.ts.map