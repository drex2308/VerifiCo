export type IPNSEntry = import('./types').IPNSEntry;
export type PublicKey = import('libp2p-crypto').PublicKey;
export type PrivateKey = import('libp2p-crypto').PrivateKey;
/**
 * @typedef {import('./types').IPNSEntry} IPNSEntry
 * @typedef {import('libp2p-crypto').PublicKey} PublicKey
 * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey
 */
/**
 * Creates a new ipns entry and signs it with the given private key.
 * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.
 * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.
 *
 * @param {PrivateKey} privateKey - private key for signing the record.
 * @param {Uint8Array} value - value to be stored in the record.
 * @param {number} seq - number representing the current version of the record.
 * @param {number} lifetime - lifetime of the record (in milliseconds).
 */
export function create(privateKey: PrivateKey, value: Uint8Array, seq: number, lifetime: number): Promise<{
    value: Uint8Array;
    signature: Uint8Array;
    validityType: number;
    validity: Uint8Array;
    sequence: number;
}>;
/**
 * Same as create(), but instead of generating a new Date, it receives the intended expiration time
 * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.
 *
 * @param {PrivateKey} privateKey - private key for signing the record.
 * @param {Uint8Array} value - value to be stored in the record.
 * @param {number} seq - number representing the current version of the record.
 * @param {string} expiration - expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.
 */
export function createWithExpiration(privateKey: PrivateKey, value: Uint8Array, seq: number, expiration: string): Promise<{
    value: Uint8Array;
    signature: Uint8Array;
    validityType: number;
    validity: Uint8Array;
    sequence: number;
}>;
/**
 * Validates the given ipns entry against the given public key.
 *
 * @param {PublicKey} publicKey - public key for validating the record.
 * @param {IPNSEntry} entry - ipns entry record.
 */
export function validate(publicKey: PublicKey, entry: IPNSEntry): Promise<void>;
/**
 * Embed the given public key in the given entry. While not strictly required,
 * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their
 * public keys as they may not be able to validate them efficiently.
 * As a consequence of nodes needing to validade a record upon receipt, they need
 * the public key associated with it. For olde RSA keys, it is easier if we just
 * send this as part of the record itself. For newer ed25519 keys, the public key
 * can be embedded in the peerId.
 *
 * @param {PublicKey} publicKey - public key to embed.
 * @param {IPNSEntry} entry - ipns entry record.
 */
export function embedPublicKey(publicKey: PublicKey, entry: IPNSEntry): Promise<import("./types").IPNSEntry | null>;
/**
 * Extracts a public key matching `pid` from the ipns record.
 *
 * @param {PeerId} peerId - peer identifier object.
 * @param {IPNSEntry} entry - ipns entry record.
 */
export function extractPublicKey(peerId: PeerId, entry: IPNSEntry): crypto.PublicKey;
/**
 * Get key for storing the record locally.
 * Format: /ipns/${base32(<HASH>)}
 *
 * @param {Uint8Array} key - peer identifier object.
 */
export function getLocalKey(key: Uint8Array): Key;
/**
 * Get key for sharing the record in the routing mechanism.
 * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}
 *
 * @param {Uint8Array} pid - peer identifier represented by the multihash of the public key as Uint8Array.
 */
export function getIdKeys(pid: Uint8Array): {
    routingPubKey: Key;
    pkKey: Key;
    routingKey: Key;
    ipnsKey: Key;
};
/**
 * @param {IPNSEntry} obj
 */
export function marshal(obj: IPNSEntry): Uint8Array;
/**
 * @param {Uint8Array} buf
 * @returns {IPNSEntry}
 */
export function unmarshal(buf: Uint8Array): IPNSEntry;
export namespace validator {
    export function validate_1(marshalledData: Uint8Array, key: Uint8Array): Promise<void>;
    export { validate_1 as validate };
    export function select(dataA: Uint8Array, dataB: Uint8Array): 1 | 0;
}
export const namespace: "/ipns/";
import PeerId = require("peer-id");
import crypto = require("libp2p-crypto");
import { Key } from "interface-datastore";
export declare const namespaceLength: number;
//# sourceMappingURL=index.d.ts.map