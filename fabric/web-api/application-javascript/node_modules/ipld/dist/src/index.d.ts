export = IPLDResolver;
/**
 * @typedef {import('interface-ipld-format').Format<object>} IPLDFormat
 * @typedef {import('multicodec').CodecCode} CodecCode
 * @typedef {import('./types').LoadFormatFn} LoadFormatFn
 * @typedef {import('./types').Options} Options
 * @typedef {import('./types').PutOptions} PutOptions
 * @typedef {import('./types').GetOptions} GetOptions
 * @typedef {import('./types').ResolveOptions} ResolveOptions
 * @typedef {import('./types').RemoveOptions} RemoveOptions
 * @typedef {import('./types').TreeOptions} TreeOptions
 */
declare class IPLDResolver {
    /**
     * @param {Options} userOptions
     */
    constructor(userOptions: Options);
    bs: any;
    /** @type {{ [key: number]: IPLDFormat}} */
    resolvers: {
        [key: number]: import("interface-ipld-format").Format<object>;
    };
    /**
     * @type {LoadFormatFn}
     */
    loadFormat: LoadFormatFn;
    /**
     * Add support for an IPLD Format.
     *
     * @param {IPLDFormat} format - The implementation of an IPLD Format.
     */
    addFormat(format: import("interface-ipld-format").Format<object>): this;
    /**
     * Remove support for an IPLD Format.
     *
     * @param {multicodec.CodecCode} codec - The codec of the IPLD Format to remove.
     */
    removeFormat(codec: multicodec.CodecCode): this;
    /**
     * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.
     *
     * @param {CID} cid - the CID the resolving starts.
     * @param {string} path - the path that should be resolved.
     * @param {ResolveOptions} [options]
     */
    resolve(cid: CID, path: string, options?: import("./types").ResolveOptions | undefined): AsyncIterable<any> & import("./util").Extensions<any>;
    /**
     * Get a node by CID.
     *
     * @param {CID} cid - The CID of the IPLD Node that should be retrieved.
     * @param {GetOptions} [options]
     */
    get(cid: CID, options?: import("./types").GetOptions | undefined): Promise<any>;
    /**
     * Get multiple nodes back from an array of CIDs.
     *
     * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.
     * @param {GetOptions} [options]
     */
    getMany(cids: Iterable<CID>, options?: import("./types").GetOptions | undefined): AsyncIterable<any> & import("./util").Extensions<any>;
    /**
     * Stores the given IPLD Node of a recognized IPLD Format.
     *
     * @param {Object} node - The deserialized IPLD node that should be inserted.
     * @param {CodecCode} format - The multicodec of the format that IPLD Node should be encoded in.
     * @param {PutOptions} [userOptions] -  Options is an object with the following properties.
     */
    put(node: Object, format: CodecCode, userOptions?: import("./types").PutOptions | undefined): Promise<CID>;
    /**
     * Stores the given IPLD Nodes of a recognized IPLD Format.
     *
     * @param {Iterable<any>} nodes - Deserialized IPLD nodes that should be inserted.
     * @param {CodecCode} format - The multicodec of the format that IPLD Node should be encoded in.
     * @param {PutOptions} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.
     */
    putMany(nodes: Iterable<any>, format: CodecCode, userOptions?: import("./types").PutOptions | undefined): AsyncIterable<any> & import("./util").Extensions<any>;
    /**
     * Remove an IPLD Node by the given CID.
     *
     * @param {CID} cid - The CID of the IPLD Node that should be removed.
     * @param {RemoveOptions} [options]
     */
    remove(cid: CID, options?: import("./types").RemoveOptions | undefined): Promise<any>;
    /**
     * Remove IPLD Nodes by the given CIDs.
     *
     * Throws an error if any of the Blocks canâ€™t be removed. This operation is
     * *not* atomic, some Blocks might have already been removed.
     *
     * @param {Iterable<CID>} cids - The CIDs of the IPLD Nodes that should be removed.
     * @param {RemoveOptions} [options]
     */
    removeMany(cids: Iterable<CID>, options?: import("./types").RemoveOptions | undefined): AsyncIterable<any> & import("./util").Extensions<any>;
    /**
     * Returns all the paths that can be resolved into.
     *
     * @param {CID} cid - The ID to get the paths from
     * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.
     * @param {TreeOptions} [userOptions]
     */
    tree(cid: CID, offsetPath?: string | undefined, userOptions?: import("./types").TreeOptions | undefined): AsyncIterable<any> & import("./util").Extensions<any>;
    /**
     * @param {CodecCode} codec
     */
    getFormat(codec: CodecCode): Promise<import("interface-ipld-format").Format<any>>;
}
declare namespace IPLDResolver {
    export { defaultOptions, IPLDFormat, CodecCode, LoadFormatFn, Options, PutOptions, GetOptions, ResolveOptions, RemoveOptions, TreeOptions };
}
type LoadFormatFn = import('./types').LoadFormatFn;
import multicodec = require("multicodec");
type CodecCode = import('multicodec').CodecCode;
import CID = require("cids");
type Options = import('./types').Options;
declare namespace defaultOptions {
    const formats: import("interface-ipld-format").Format<object>[];
}
type IPLDFormat = import('interface-ipld-format').Format<object>;
type PutOptions = import('./types').PutOptions;
type GetOptions = import('./types').GetOptions;
type ResolveOptions = import('./types').ResolveOptions;
type RemoveOptions = import('./types').RemoveOptions;
type TreeOptions = import('./types').TreeOptions;
//# sourceMappingURL=index.d.ts.map