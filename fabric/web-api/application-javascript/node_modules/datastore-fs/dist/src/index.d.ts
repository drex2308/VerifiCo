export = FsDatastore;
/**
 * A datastore backed by the file system.
 *
 * Keys need to be sanitized before use, as they are written
 * to the file system as is.
 *
 * @implements {Datastore}
 */
declare class FsDatastore extends Adapter implements Datastore {
    /**
     * @param {string} location
     * @param {{ createIfMissing?: boolean; errorIfExists?: boolean; extension?: string; } | undefined} [opts]
     */
    constructor(location: string, opts?: {
        createIfMissing?: boolean;
        errorIfExists?: boolean;
        extension?: string;
    } | undefined);
    path: string;
    opts: {
        createIfMissing: boolean;
        errorIfExists: boolean;
        extension: string;
    } & {
        createIfMissing?: boolean | undefined;
        errorIfExists?: boolean | undefined;
        extension?: string | undefined;
    };
    /**
     * Calculate the directory and file name for a given key.
     *
     * @private
     * @param {Key} key
     * @returns {{dir:string, file:string}}
     */
    private _encode;
    /**
     * Calculate the original key, given the file name.
     *
     * @private
     * @param {string} file
     * @returns {Key}
     */
    private _decode;
    /**
     * Write to the file system without extension.
     *
     * @param {Key} key
     * @param {Uint8Array} val
     * @returns {Promise<void>}
     */
    putRaw(key: Key, val: Uint8Array): Promise<void>;
    /**
     * Read from the file system without extension.
     *
     * @param {Key} key
     * @returns {Promise<Uint8Array>}
     */
    getRaw(key: Key): Promise<Uint8Array>;
}
declare namespace FsDatastore {
    export { Datastore, Pair, Query, KeyQuery };
}
type Datastore = import('interface-datastore').Datastore;
import { Adapter } from "interface-datastore";
import { Key } from "interface-datastore";
type Pair = import('interface-datastore').Pair;
type Query = import('interface-datastore').Query;
type KeyQuery = import('interface-datastore').KeyQuery;
//# sourceMappingURL=index.d.ts.map