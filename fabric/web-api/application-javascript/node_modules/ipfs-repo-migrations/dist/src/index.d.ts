export type Migration = import('./types').Migration;
export type ProgressCallback = import('./types').ProgressCallback;
export type MigrationProgressCallback = import('./types').MigrationProgressCallback;
import errors = require("./errors");
/**
 * Returns the version of latest migration.
 * If no migrations are present returns 0.
 *
 * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.
 */
export function getLatestMigrationVersion(migrations?: import("./types").Migration[] | undefined): number;
/**
 * Main function to execute forward migrations.
 * It acquire lock on the provided path before doing any migrations.
 *
 * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)
 *
 * @param {string} path - Path to initialized (!) JS-IPFS repo
 * @param {object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.
 * @param {number} toVersion - Version to which the repo should be migrated.
 * @param {object} [options] - Options for migration
 * @param {boolean} [options.ignoreLock] - Won't lock the repo for applying the migrations. Use with caution.
 * @param {ProgressCallback} [options.onProgress] - Callback which will be called after each executed migration to report progress
 * @param {boolean} [options.isDryRun] - Allows to simulate the execution of the migrations without any effect.
 * @param {Migration[]} [options.migrations] - Array of migrations to perform. If undefined, the bundled migrations are used. Mainly for testing purpose.
 */
export function migrate(path: string, repoOptions: object, toVersion: number, { ignoreLock, onProgress, isDryRun, migrations }?: {
    ignoreLock?: boolean | undefined;
    onProgress?: import("./types").ProgressCallback | undefined;
    isDryRun?: boolean | undefined;
    migrations?: import("./types").Migration[] | undefined;
} | undefined): Promise<void>;
/**
 * Main function to execute backward migration (reversion).
 * It acquire lock on the provided path before doing any migrations.
 *
 * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)
 *
 * @param {string} path - Path to initialized (!) JS-IPFS repo
 * @param {object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.
 * @param {number} toVersion - Version to which the repo will be reverted.
 * @param {object} [options] - Options for the reversion
 * @param {ProgressCallback} [options.onProgress] - Callback which will be called after each reverted migration to report progress
 * @param {boolean} [options.isDryRun] - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.
 * @param {boolean} [options.ignoreLock] - Won't lock the repo for reverting the migrations. Use with caution.
 * @param {Migration[]} [options.migrations] - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.
 */
export function revert(path: string, repoOptions: object, toVersion: number, { ignoreLock, onProgress, isDryRun, migrations }?: {
    onProgress?: import("./types").ProgressCallback | undefined;
    isDryRun?: boolean | undefined;
    ignoreLock?: boolean | undefined;
    migrations?: import("./types").Migration[] | undefined;
} | undefined): Promise<void>;
export { getVersion as getCurrentRepoVersion, errors };
//# sourceMappingURL=index.d.ts.map