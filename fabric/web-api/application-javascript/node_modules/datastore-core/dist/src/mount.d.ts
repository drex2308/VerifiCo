export = MountDatastore;
/**
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {import('interface-datastore').Options} Options
 * @typedef {import('interface-datastore').Batch} Batch
 * @typedef {import('interface-datastore').Query} Query
 * @typedef {import('interface-datastore').KeyQuery} KeyQuery
 * @typedef {import('./types').KeyTransform} KeyTransform
 */
/**
 * @template TEntry
 * @typedef {import('./types').AwaitIterable<TEntry>} AwaitIterable
 */
/**
 * A datastore that can combine multiple stores inside various
 * key prefixes
 *
 * @implements {Datastore}
 */
declare class MountDatastore extends Adapter implements Datastore {
    /**
     * @param {Array<{prefix: Key, datastore: Datastore}>} mounts
     */
    constructor(mounts: Array<{
        prefix: Key;
        datastore: Datastore;
    }>);
    mounts: {
        prefix: Key;
        datastore: Datastore;
    }[];
    /**
     * Lookup the matching datastore for the given key
     *
     * @private
     * @param {Key} key
     * @returns {{datastore: Datastore, mountpoint: Key, rest: Key} | undefined}
     */
    private _lookup;
}
declare namespace MountDatastore {
    export { Datastore, Options, Batch, Query, KeyQuery, KeyTransform, AwaitIterable };
}
import { Adapter } from "interface-datastore";
import { Key } from "interface-datastore";
type Datastore = import("interface-datastore/dist/src/types").Datastore;
type Options = import("interface-datastore/dist/src/types").Options;
type Batch = import("interface-datastore/dist/src/types").Batch;
type Query = import("interface-datastore/dist/src/types").Query;
type KeyQuery = import("interface-datastore/dist/src/types").KeyQuery;
type KeyTransform = import("./types").KeyTransform;
type AwaitIterable<TEntry> = Iterable<TEntry> | AsyncIterable<TEntry>;
//# sourceMappingURL=mount.d.ts.map